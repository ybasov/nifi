<!DOCTYPE html>
<html lang="en">
    <!--
      Licensed to the Apache Software Foundation (ASF) under one or more
      contributor license agreements.  See the NOTICE file distributed with
      this work for additional information regarding copyright ownership.
      The ASF licenses this file to You under the Apache License, Version 2.0
      (the "License"); you may not use this file except in compliance with
      the License.  You may obtain a copy of the License at
          http://www.apache.org/licenses/LICENSE-2.0
      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    -->
    <head>
        <meta charset="utf-8"/>
        <title>JsonPathReader</title>
        <link rel="stylesheet" href="../../css/component-usage.css" type="text/css"/>
    </head>

    <body>
        <p>
        	The JsonPathReader Controller Service, parses FlowFiles that are in the JSON format. User-defined properties
        	specify how to extract all relevant fields from the JSON in order to create a row-oriented record. The Controller
        	Service will not be valid unless at least one JSON Path is provided. Unlike the
        	<a href="../org.apache.nifi.json.FlatJsonReader/additionalDetails.html">FlatJsonReader</a> Controller Service, this
        	service will return a record that contains only those fields that have been configured via JSON Path.
        </p>
        
        <p>
        	If the root of the FlowFile's JSON is a JSON Array, each JSON Object found in that array will be treated as a separate
        	Record, not as a single record made up of an array. If the root of the FlowFile's JSON is a JSON Object, it will be
        	evaluated as a single Record.
        </p>
        
        <p>
        	Supplying a JSON Path is accomplished by adding a user-defined property where the name of the property becomes the name
        	of the field in the Record that is returned. The value of the property must be a valid JSON Path expression. This JSON Path
        	will be evaluated against each top-level JSON Object in the FlowFile, and the result will be the value of the field whose
        	name is specified by the property name. By default, the type of each field is inferred automatically based on the values of
        	the first JSON Object encountered for the FlowFile. This can be overridden by changing the name of the user-defined property
        	by adding a colon (:) and specifying the data type. For example: <code>balance:double</code> or <code>dob:date:MM/dd/yyyy</code>.
        	In this case, the data type and option format are not included in the field name. So for the aforementioned examples, we would
        	end up with field names <code>balance</code> and <code>dob</code>.
        </p>
        
		<p>
        	When specifying a data type for a field, the following values are valid:
        </p>
        
        <ul>
        	<li><b>string</b></li>
        	<li><b>boolean</b></li>
        	<li><b>byte</b></li>
        	<li><b>char</b></li>
        	<li><b>short</b></li>
        	<li><b>int</b></li>
        	<li><b>bigint</b></li>
        	<li><b>long</b></li>
        	<li><b>float</b></li>
        	<li><b>double</b></li>
        	<li><b>date</b> - A date with no time field. By default, the format used is <code>yyyy-MM-dd</code>. This can be overridden
        		by adding a colon (:) followed by the desired format. For example: <code>date:MM/dd/yyyy</code>. The format to use is
        		that of Java's SimpleDateFormat (see <a href="http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">
        		SimpleDateFormat Patterns</a> for more information).
        	</li>
        	<li><b>time</b> - A time with no date field. By default, the format used is <code>HH:mm:ss</code>. This can be overridden
        		by adding a colon (:) followed by the desired format. For example: <code>time:hh:mm:ss a</code>. The format to use is
        		that of Java's SimpleDateFormat (see <a href="http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">
        		SimpleDateFormat Patterns</a> for more information).
        	</li>
        	<li><b>timestamp</b> - A field that represents both a date and time. By default, the format used is
        		<code>yyyy-MM-dd HH:mm:ss</code>. This can be overridden by adding a colon (:) followed by the desired format. For example:
        		<code>MM/dd/yyyy hh:mm:ss a</code>. The format to use is
        		that of Java's SimpleDateFormat (see <a href="http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html">
        		SimpleDateFormat Patterns</a> for more information).</li>
        	<li><b>object</b> - The value will be returned as a <code>Map&lt;String, Object&gt;</code>. The types of the values in the Map
        		are always inferred. The type used for the values may not be the same for each record. For example, consider the following
        		JSON array:
        			<br /><br />
        			<code>
        			[{
        			    id: 17,
        			  	name: "John",
        			    child: {
        			    	id: "1"
        			    },
        			    siblingIds: [4, "8"]
        			  },
        			  <br />{
        			  	id: 98,
        			    name: "Jane",
        			    child: {
        			        id: 2
        			    },
        			    siblingIds: []
        			  }]
        			</code>
        			<br /><br />
        		In this case, the <code>child</code> element would be inferred to be of type <code>object</code>. Since nested types
        		are inferred on a per-record basis, for the first record, the <code>child</code> field would return a <code>Map</code>
        		where the value of the <code>id</code> entry is a <code>string</code>. However, for the second record, the <code>child</code>
        		field would return a <code>Map</code> where the value of the <code>id</code> entry is an <code>int</code>.
        		<br />
        		Moreover, the <code>siblingIds</code> of the John will be an <code>array</code> where the first element is an <code>int</code>
        		and the second element is a <code>string</code>. The <code>siblingIds</code> of Jane will be an empty array.
        		</li>
        	<li><b>array</b> - An array of values. The types of the values are always inferred and may not be the same for each element
        		in the array, or for two arrays from different JSON objects.</li>
        </ul>


        <p>
        	As an example, consider a FlowFile whose content contains the following JSON:
        </p>
        
        <code>
			[{
			    id: 17,
			  	name: "John",
			    child: {
			    	id: "1"
			    },
			    siblingIds: [4, "8"]
			  },
			  <br />{
			  	id: 98,
			    name: "Jane",
			    child: {
			        id: 2
			    },
			    gender: "F",
			    siblingIds: []
			  }]
        </code>
        
        <p>
        	If we configure this Controller Service with the following user-defined properties:
        	
        	<table>
        		<head>
        			<th>Property Name</th>
        			<th>Property Value</th>
        		</head>
        		<body>
        			<tr>
        				<td>id</td>
        				<td><code>$.id</code></td>
        			</tr>
        			<tr>
        				<td>name</td>
        				<td><code>$.name</code></td>
        			</tr>
        			<tr>
        				<td>childId:long</td>
        				<td><code>$.child.id</code></td>
        			</tr>
        			<tr>
        				<td>gender:string</td>
        				<td><code>$.gender</code></td>
        			</tr>
        		</body>
        	</table>
        </p>
        
		<p>
			In this case, the FlowFile will generate two Records. The first record will consist of the following key/value pairs:

        	<table>
        		<head>
        			<th>Field Name</th>
        			<th>Field Value</th>
        		</head>
        		<body>
        			<tr>
        				<td>id</td>
        				<td>17</td>
        			</tr>
        			<tr>
        				<td>name</td>
        				<td>John</td>
        			</tr>
        			<tr>
        				<td>childId</td>
        				<td>1</td>
        			</tr>
        			<tr>
        				<td>gender</td>
        				<td><i>null</i></td>
        			</tr>
				</body>
			</table>
		</p>
		
		<p>
			The second record will consist of the following key/value pairs:

        	<table>
        		<head>
        			<th>Field Name</th>
        			<th>Field Value</th>
        		</head>
        		<body>
        			<tr>
        				<td>id</td>
        				<td>98</td>
        			</tr>
        			<tr>
        				<td>name</td>
        				<td>Jane</td>
        			</tr>
        			<tr>
        				<td>childId</td>
        				<td>2</td>
        			</tr>
        			<tr>
        				<td>gender</td>
        				<td>F</td>
        			</tr>
				</body>
			</table>
		</p>
		
    </body>
</html>
